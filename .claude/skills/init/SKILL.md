---
name: init
description: "Initialize dev session — pull Linear, generate local caches, present dashboard"
disable-model-invocation: true
argument-hint: "[ROK-XXX | planning | sprint]"
allowed-tools: "Read, Write, Glob, Grep, Bash(git status*), Bash(git log*), Bash(git diff*), mcp__linear__list_issues, mcp__linear__get_issue"
---

# Session Init

Initialize a development session by pulling current state from Linear (source of truth) and regenerating lightweight local cache files.

**Principle:** Linear is the single source of truth. Local files are regenerated caches:
- `planning-artifacts/sprint-status.yaml` — full project status snapshot (Linear cache)
- `task.md` — session working doc with checkboxes that drive `/handover` sync

## Step 1 — Parallel Data Gathering

Fetch ALL of the following in a single parallel tool-call block:

1. **Linear issues:** `mcp__linear__list_issues` with `project: "Raid Ledger"`, `limit: 250`
2. **Council decisions:** Read `planning-artifacts/council-decisions.md`
3. **Story file count:** Glob `implementation-artifacts/stories/ROK-*.md`
4. **Git state:** Run `git status --porcelain` and `git log --oneline -5` (two Bash calls)
5. **Focus story (conditional):** If `$ARGUMENTS` matches the pattern `ROK-` followed by digits, also read `implementation-artifacts/stories/$ARGUMENTS.md`

Do NOT read AGENTS.md — it is redundant with CLAUDE.md which is auto-loaded.

## Step 2 — Regenerate Local Caches

### 2a. sprint-status.yaml (Linear → local)

From the Linear issues response, **overwrite** `planning-artifacts/sprint-status.yaml`:

```yaml
# generated: <ISO-8601 timestamp>
# source: Linear (Raid Ledger project) — do not hand-edit
# regenerate: /init pulls from Linear, /handover pushes then pulls
project: Raid Ledger
tracking_system: linear

development_status:
  # === Done ===
  ROK-XXX: done           # <issue title>

  # === In Progress ===
  ROK-XXX: in-progress    # <issue title>

  # === Ready for Dev ===
  ROK-XXX: ready-for-dev  # <issue title>

  # === Review ===
  ROK-XXX: review         # <issue title>

  # === Backlog ===
  ROK-XXX: backlog        # <issue title>

  # === Deprecated ===
  ROK-XXX: deprecated     # <issue title>
```

**Status mapping (Linear → local):**

| Linear Status | Local Status |
|---|---|
| Done | `done` |
| In Progress | `in-progress` |
| Todo | `ready-for-dev` |
| In Review | `review` |
| Backlog | `backlog` |
| Canceled | `deprecated` |
| Duplicate | *(skip — do not include)* |

Sort entries by ROK number (ascending) within each status group. Omit empty groups.

### 2b. task.md (Session working doc)

**Overwrite** `task.md` with the session's working document:

```markdown
# Session: <YYYY-MM-DD>
<!-- Generated by /init from Linear — checkboxes drive /handover sync -->
<!-- [x] = done (pushes Done to Linear) -->
<!-- [/] = in progress (pushes In Progress to Linear) -->
<!-- [ ] = not started (no change in Linear) -->

## In Progress
- [/] ROK-XXX: <title>

## Ready for Dev
- [ ] ROK-XXX: <title>  (<priority>)
- [ ] ROK-XXX: <title>  (<priority>)

## Session Notes
<!-- Add context, blockers, decisions as you work -->
```

Populate from Linear issues:
- **In Progress:** All issues with status "In Progress", sorted by ROK number
- **Ready for Dev:** All issues with status "Todo", sorted by priority (Urgent > High > Normal > Low > None), then by ROK number. Limit to top 15.
- Include priority label in parentheses: `(P0)` for Urgent, `(P1)` for High, `(P2)` for Normal, `(P3)` for Low. Omit if None.

## Step 3 — Compute Derived Values

### Current Phase
Find the **last** `### Revised Phase Structure` block in `council-decisions.md`. Within its code fence, find the line containing `CURRENT`. Extract the phase name and description.

### Next Story Number
From the Glob results of `implementation-artifacts/stories/ROK-*.md`, extract all numeric suffixes, find the highest, and add 1.

### Top 3 Priorities
From the Ready for Dev section of task.md, take the first 3 entries (already sorted by priority).

## Step 4 — Present Dashboard & Checkpoint

Output a single compact dashboard:

```
Session Init | <YYYY-MM-DD>
<Phase name> | <Sprint info from roadmap>

Stories: <count> files | Next: ROK-<N>
Git: <branch> | <clean/dirty — e.g. "3 modified, 1 untracked">
Recent: <latest commit one-liner>
Linear: <total issues> synced → sprint-status.yaml + task.md regenerated

Top Priorities:
  1. ROK-XXX  <priority>  <title>
  2. ROK-XXX  <priority>  <title>
  3. ROK-XXX  <priority>  <title>

Summary: <done> done | <in-progress> active | <ready> ready | <backlog> backlog
```

### Checkpoint Behavior

Route based on `$ARGUMENTS`:

- **No arguments:** After the dashboard, present: "Path? **active-sprint** or **planning**" — then wait for the user to choose.
- **`sprint`:** After the dashboard, output: "Routing to active sprint. Top priority: ROK-XXX — <title>." — then stop.
- **`planning`:** After the dashboard, output: "Routing to planning mode." — then stop.
- **`ROK-XXX`** (a specific story ID): After the dashboard, append a **Focus Story** section:
  ```
  --- Focus: ROK-XXX ---
  Status: <status from Linear>
  <First 3 lines of the story file's "## Story" section>
  ACs: <count of acceptance criteria checkboxes>
  Deps: <dependency list or "none">
  ```
  Then stop.
