# ====================
# Raid Ledger All-In-One Docker Image
# ====================
# Complete stack: PostgreSQL + Redis + API + Nginx
# Usage: docker run -p 80:80 -v raid-ledger-data:/data ghcr.io/sjdodge123/raid-ledger:main
#
# Environment Variables:
#   PORT           - External port (default: 80)
#   ADMIN_PASSWORD - Set a specific admin password on first run (default: random)
#   CORS_ORIGIN    - Allowed CORS origin (default: auto-derived from RENDER_EXTERNAL_URL or localhost)
#
# Data is persisted under /data (PostgreSQL + Redis). Mount a volume to
# retain data across container updates (e.g. Watchtower).
# ====================

# ====================
# Stage 1: Dependencies
# ====================
FROM node:20-alpine AS deps

WORKDIR /app

COPY package*.json ./
COPY api/package*.json ./api/
COPY web/package*.json ./web/
COPY packages/contract/package*.json ./packages/contract/

RUN npm ci

# ====================
# Stage 2: Build
# ====================
FROM deps AS builder

WORKDIR /app

COPY . .

# Build contract, API, and Web
RUN npm run build -w @raid-ledger/contract
RUN npm run build -w @raid-ledger/api
ENV VITE_API_URL=/api
RUN npm run build -w @raid-ledger/web

# ====================
# Stage 3: Production Runtime
# ====================
FROM node:20-alpine AS production

# Install all required services
RUN apk add --no-cache \
  nginx \
  postgresql16 \
  postgresql16-contrib \
  redis \
  supervisor \
  bash \
  su-exec \
  gettext

# Create app user and directories
RUN addgroup -g 1001 -S app && \
  adduser -S -D -H -u 1001 -G app app

WORKDIR /app

# ==================
# Persistent data volume ‚Äî mount as -v raid-ledger-data:/data
# ==================
RUN mkdir -p /data/postgresql /data/redis /run/postgresql /run/redis && \
  chown -R postgres:postgres /data/postgresql /run/postgresql && \
  chown -R redis:redis /data/redis /run/redis
VOLUME /data

ENV PGDATA=/data/postgresql

# ==================
# Nginx Setup
# ==================
RUN mkdir -p /run/nginx && \
  chown -R app:app /run/nginx /var/lib/nginx /var/log/nginx

# Copy built Web static files
COPY --from=builder /app/web/dist /usr/share/nginx/html

# Nginx config template (port resolved at runtime via envsubst)
COPY nginx/monolith.conf.template /etc/nginx/http.d/default.conf.template

# ==================
# API Setup
# ==================
COPY --from=builder /app/api/dist ./dist
COPY --from=builder /app/api/package.json ./package.json
COPY --from=builder /app/api/assets ./assets
COPY --from=builder /app/api/src/drizzle/migrations ./drizzle/migrations
COPY --from=builder /app/node_modules ./node_modules
COPY --from=builder /app/packages/contract/dist ./node_modules/@raid-ledger/contract/dist
COPY --from=builder /app/packages/contract/package.json ./node_modules/@raid-ledger/contract/package.json

# Copy seed scripts and data
COPY --from=builder /app/api/dist/scripts ./dist/scripts
COPY --from=builder /app/api/seeds ./dist/seeds

# Copy entrypoint
COPY api/scripts/docker-entrypoint.sh /usr/local/bin/docker-entrypoint.sh
RUN chmod +x /usr/local/bin/docker-entrypoint.sh

# ==================
# Supervisor Config
# ==================
RUN mkdir -p /etc/supervisor.d

# Create all-in-one supervisor config
COPY <<'EOF' /etc/supervisor.d/raid-ledger.ini
[unix_http_server]
file=/run/supervisor.sock
chmod=0700
username=admin
password=admin

[supervisorctl]
serverurl=unix:///run/supervisor.sock
username=admin
password=admin

[supervisord]
nodaemon=true
user=root
logfile=/dev/stdout
logfile_maxbytes=0
loglevel=warn
pidfile=/run/supervisord.pid

[program:postgres]
command=/sbin/su-exec postgres /usr/libexec/postgresql16/postgres -D /data/postgresql -c log_min_messages=FATAL
autostart=true
autorestart=true
priority=10
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
redirect_stderr=true
stopwaitsecs=5
stopsignal=TERM
killasgroup=true
stopasgroup=true

[program:redis]
command=/usr/bin/redis-server --dir /data/redis --daemonize no --port 0 --unixsocket /tmp/redis.sock --unixsocketperm 700
user=redis
autostart=true
autorestart=true
priority=20
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
redirect_stderr=true
stopwaitsecs=5
stopsignal=TERM

[program:nginx]
command=/usr/sbin/nginx -g "daemon off;"
autostart=true
autorestart=true
priority=30
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
redirect_stderr=true

[program:api]
command=/app/start-api.sh
directory=/app
environment=PORT=3000
autostart=true
autorestart=true
priority=40
startsecs=15
startretries=5
stdout_logfile=/dev/stdout
stdout_logfile_maxbytes=0
redirect_stderr=true
EOF

# Create API startup script (waits for PostgreSQL + Redis)
COPY <<'EOF' /app/start-api.sh
#!/bin/bash
set -e

# Wait for PostgreSQL to be ready
echo "‚è≥ Waiting for PostgreSQL..."
until /sbin/su-exec postgres pg_isready -q; do
  sleep 1
done
echo "‚úÖ PostgreSQL is ready"

# Wait for Redis to be ready (Unix socket)
echo "‚è≥ Waiting for Redis..."
until redis-cli -s /tmp/redis.sock ping > /dev/null 2>&1; do
  sleep 1
done
echo "‚úÖ Redis is ready"

# Auto-derive CORS_ORIGIN for all-in-one image if not explicitly set.
# Render provides RENDER_EXTERNAL_URL; otherwise keep "auto" so the API
# dynamically allows the request's own origin (works on any hostname).
if [ -z "$CORS_ORIGIN" ]; then
  export CORS_ORIGIN="auto"
fi
if [ "$CORS_ORIGIN" = "auto" ] && [ -n "$RENDER_EXTERNAL_URL" ]; then
  export CORS_ORIGIN="$RENDER_EXTERNAL_URL"
  echo "üåê CORS_ORIGIN derived from Render: $CORS_ORIGIN"
else
  echo "üåê CORS_ORIGIN: $CORS_ORIGIN"
fi

# Auto-derive CLIENT_URL from CORS_ORIGIN when not explicitly set.
# The /event plan Discord command and poll embeds need this to generate links.
if [ -z "$CLIENT_URL" ] && [ -n "$CORS_ORIGIN" ] && [ "$CORS_ORIGIN" != "auto" ]; then
  export CLIENT_URL="$CORS_ORIGIN"
  echo "üîó CLIENT_URL derived from CORS_ORIGIN: $CLIENT_URL"
fi

# Run entrypoint (migrations, admin bootstrap, seeding)
cd /app
exec /usr/local/bin/docker-entrypoint.sh node /app/dist/src/main.js
EOF
RUN chmod +x /app/start-api.sh

# Create init script to set up PostgreSQL on first run
COPY <<'EOF' /app/init-db.sh
#!/bin/bash
set -e

# Initialize PostgreSQL if not already done
if [ ! -s "${PGDATA}/PG_VERSION" ]; then
  echo "üì¶ Initializing PostgreSQL database..."
  /sbin/su-exec postgres initdb -D "${PGDATA}" --auth-local=trust --auth-host=trust > /dev/null 2>&1
  
  # Start PostgreSQL temporarily to create database (quiet LOG-level output)
  /sbin/su-exec postgres pg_ctl -D "${PGDATA}" -o "-k /run/postgresql -c log_min_messages=FATAL" -w start 2>/dev/null

  # Create user and database
  /sbin/su-exec postgres psql -q -c "CREATE USER raid_ledger WITH PASSWORD 'raid_ledger';"
  /sbin/su-exec postgres psql -q -c "CREATE DATABASE raid_ledger OWNER raid_ledger;"
  /sbin/su-exec postgres psql -q -c "GRANT ALL PRIVILEGES ON DATABASE raid_ledger TO raid_ledger;"

  # Stop PostgreSQL (supervisor will start it)
  /sbin/su-exec postgres pg_ctl -D "${PGDATA}" -m fast -w stop 2>/dev/null
  
  echo "‚úÖ PostgreSQL initialized"
fi
EOF
RUN chmod +x /app/init-db.sh

# Create main entrypoint
COPY <<'EOF' /app/entrypoint.sh
#!/bin/bash
set -e

# Ensure /data subdirectories exist and have correct ownership
# (volume mounts may arrive as root-owned empty dirs)
mkdir -p /data/postgresql /data/redis
chown -R postgres:postgres /data/postgresql
chown -R redis:redis /data/redis

# Initialize database on first run
/app/init-db.sh

# Resolve nginx listen port from $PORT (Render injects PORT=10000)
export NGINX_PORT="${PORT:-80}"
envsubst '${NGINX_PORT}' < /etc/nginx/http.d/default.conf.template > /etc/nginx/http.d/default.conf

# Start all services via supervisor
exec supervisord -c /etc/supervisord.conf
EOF
RUN chmod +x /app/entrypoint.sh

# ==================
# Environment Defaults
# ==================
ARG COMMIT_SHA=""
ENV COMMIT_SHA=${COMMIT_SHA}
ENV NODE_ENV=production
ENV DATABASE_URL=postgresql://raid_ledger:raid_ledger@localhost:5432/raid_ledger
ENV REDIS_URL=/tmp/redis.sock
ENV JWT_SECRET=raid-ledger-default-secret-change-in-production
ENV DOTENV_CONFIG_QUIET=true
ENV CORS_ORIGIN=auto
ENV CLIENT_URL=
ENV ADMIN_PASSWORD=

# Expose port (nginx)
EXPOSE 80

# Health check
HEALTHCHECK --interval=30s --timeout=5s --start-period=60s --retries=3 \
  CMD wget --no-verbose --tries=1 --spider http://localhost:${PORT:-80}/api/health || exit 1

# Start everything
ENTRYPOINT ["/app/entrypoint.sh"]
